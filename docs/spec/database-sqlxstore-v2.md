# Neton Database - SqlxStore 内部接口参考

> **业务层请以 Entity 为中心 API 为准**：`UserStore.get(id)`、`UserStore.destroy(id)`、`UserStore.update(id){ }`、`UserStore.where { }`、`user.save()`、`user.delete()`。详见 [neton-database-query-dsl-v2.md](./database-query-dsl.md)。  
> **主路径**：KSP 生成 `object UserStore : Store&lt;User&gt; by SqlxStoreAdapter`，`database { storeRegistry = { ... } }` 传入，不依赖 DatabaseManager。  
> 本文为 **Store 内部实现与设计原则** 参考，不暴露 Repository/Impl。

---

## 1. 设计原则（强制）

| 原则 | 说明 |
|------|------|
| **业务层以 Entity API 为准** | 使用 `User.get` / `User.where` / `user.save` 等，不直接使用 Store |
| **Store 为内部实现** | KSP 生成 Store，业务层不引用 Store/Repository |
| **禁止直接使用 sqlx Database** | 业务层不得持有或调用 Database |
| **禁止运行时反射** | 实体映射用 KSP 或手写 RowMapper |
| **禁止拼接 SQL** | 一律参数化 Statement |
| **单一实现** | 只有 SqlxStore，无 memory/sqlite 多套 |
| **Store 必须无状态（stateless）** | 不得在 Store 内缓存 entity 或持有 mutable 状态；Store = 纯函数式 + db 代理 |

### 1.1 长期规范（铁律，3~5 年稳定性的保险）

以下规则写死，不得放松：

| 规则 | 表述 |
|------|------|
| **Store 无状态 + 线程安全** | `Store MUST be stateless and thread-safe.` `Store MUST NOT hold mutable state or cache entities.` |
| **SQL 编译期生成** | `All SQL must be compile-time generated by KSP.` `Manual string concatenation SQL is forbidden.` |
| **唯一 Store 实现** | `SqlxStore is the only official Store implementation.` `Custom Store implementations are not supported.` 缓存/多数据源应作为 Store 的包装层，而非替代实现。 |

---

## 2. 核心 API 草图

### 2.1 Store 接口（保持 + 扩展）

```kotlin
interface Store<T : Any> {
    // ===== 基础 CRUD =====
    suspend fun findById(id: Any): T?
    suspend fun findAll(): List<T>
    suspend fun insert(entity: T): T
    suspend fun update(entity: T): Boolean
    suspend fun save(entity: T): T
    suspend fun delete(entity: T): Boolean
    suspend fun deleteById(id: Any): Boolean
    suspend fun count(): Long
    suspend fun exists(id: Any): Boolean
    
    // ===== Batch API（新增）======
    suspend fun insertBatch(entities: List<T>): Int
    suspend fun updateBatch(entities: List<T>): Int
    suspend fun saveAll(entities: List<T>): List<T>
    
    // ===== Query DSL =====
    fun query(): QueryBuilder<T>
    
    // ===== 事务 =====
    suspend fun <R> withTransaction(block: suspend Store<T>.() -> R): R
}
```

### 2.2 ActiveRecord 风格扩展（语法糖）

```kotlin
// 实体基类（可选，给需要 Active Record 体验的实体用）
abstract class Entity<T : Any> {
    abstract val id: Any?
    
    suspend fun save(): T = store<T>().save(this as T)
    suspend fun delete(): Boolean = store<T>().delete(this as T)
    suspend fun refresh(): T? = id?.let { store<T>().findById(it) }
    
    protected fun store(): Store<T> = ...  // legacy：主路径使用 KSP UserStore，不继承 Entity
    protected abstract fun entityClass(): KClass<T>
}

// 或通过扩展函数（不改实体继承）
suspend fun <T : Any> T.save(store: Store<T>): T = store.save(this)
suspend fun <T : Any> T.delete(store: Store<T>): Boolean = store.delete(this)

// 定型 API（KSP 生成，业务层只写这些）
User.get(id)
User.destroy(id)
User.update(id) { name = x; email = y }  // mutate 风格，KSP 生成 XxxUpdateScope，copy 在内部
User.where { ... }.list()
user.save()
user.delete()
```

**当前规范**：不暴露 Store/Repository，KSP 生成 Companion 与实例扩展。

---

## 3. Statement 缓存（静态化）

### 3.1 KSP 生成 Statements object（推荐）

```kotlin
// KSP 生成 - classloader 级共享，零实例分配
object UserStatements {
    val selectById = Statement.create("SELECT * FROM users WHERE id = :id")
    val selectAll = Statement.create("SELECT * FROM users")
    val countAll = Statement.create("SELECT COUNT(*) FROM users")
    val insert = Statement.create("INSERT INTO users (id, name, age) VALUES (:id, :name, :age)")
    val update = Statement.create("UPDATE users SET name = :name, age = :age WHERE id = :id")
    val deleteById = Statement.create("DELETE FROM users WHERE id = :id")
}
```

### 3.2 SqlxStore 引用静态 Statement

```kotlin
// EntityStatements 接口约束
interface EntityStatements {
    val selectById: Statement
    val selectAll: Statement
    val countAll: Statement
    val insert: Statement
    val update: Statement
    val deleteById: Statement
}

// Store 单例化：object 而非每次 new（主路径用 SqlxStoreAdapter + SqlxDatabase.require()）
object UserStore : SqlxStore<User>(
    db = SqlxDatabase.require(),
    statements = UserStatements,
    mapper = UserRowMapper,
    toParams = { mapOf("id" to it.id, "name" to it.name, "age" to it.age) },
    getId = { it.id }
)

class SqlxStore<T : Any>(
    private val db: Database,
    private val statements: EntityStatements,
    private val mapper: RowMapper<T>,
    private val toParams: (T) -> Map<String, Any?>,
    private val getId: (T) -> Any?
) : Store<T> {
    override suspend fun findById(id: Any): T? =
        db.fetchAll(statements.selectById.bind("id", id), mapper).getOrThrow().firstOrNull()
    // ...
}
```

### 3.3 要点

- Statement 在 **object** 中，classloader 级共享
- Store 使用 **object 单例**，主路径不依赖 DatabaseManager，由 storeRegistry 注入
- 由 KSP 按 `@Entity` 生成 `XxxStatements`

---

## 4. Batch API 实现

```kotlin
override suspend fun insertBatch(entities: List<T>): Int {
    if (entities.isEmpty()) return 0
    return db.transaction {
        var count = 0
        for (e in entities) {
            execute(statements.insert.bind(toParams(e))).getOrThrow()
            count++
        }
        count
    }.getOrThrow()
}

override suspend fun updateBatch(entities: List<T>): Int {
    if (entities.isEmpty()) return 0
    return db.transaction {
        var count = 0
        for (e in entities) {
            execute(statements.update.bind(toParams(e))).getOrThrow()
            count++
        }
        count
    }.getOrThrow()
}

override suspend fun saveAll(entities: List<T>): List<T> {
    return db.transaction {
        entities.map { e ->
            val id = getId(e)
            if (id == null || isNew(id)) {
                execute(statements.insert.bind(toParams(e))).getOrThrow()
                e
            } else {
                execute(statements.update.bind(toParams(e))).getOrThrow()
                e
            }
        }
    }.getOrThrow()
}
```

- 批量操作在**单事务**内执行
- 若 sqlx4k 提供 `executeBatch`，可再优化

---

## 5. QueryBuilder 类型安全 DSL（目标形态）

```kotlin
// 用法
val users = UserStore.query {
    where(User::age gt 18)
    and(User::status eq "active")
    orderBy(User::createdAt.desc())
    limit(20)
}.fetch()

// 实现：KProperty1 -> column name
fun <T : Any, V> QueryContext<T>.field(prop: KProperty1<T, V>): TypedFieldRef<T, V>

// 运算符
infix fun <V> TypedFieldRef<T, V>.eq(value: V): QueryCondition
infix fun <V : Comparable<V>> TypedFieldRef<T, V>.gt(value: V): QueryCondition
// ...
```

- 由 KSP 或注解生成 `User::age` → `"age"` 的列名映射
- 避免字符串、保证编译期类型检查

---

## 6. KSP 自动生成 Store（可选）

```kotlin
@Entity("users")
data class User(
    @Id val id: Long = 0,
    val name: String,
    val age: Int
)

// KSP 生成：UserStatements + UserStore
object UserStatements : EntityStatements { /* ... */ }

object UserStore : SqlxStore<User>(
    db = DatabaseManager.require(),
    statements = UserStatements,
    mapper = UserRowMapper,
    toParams = { mapOf("id" to it.id, "name" to it.name, "age" to it.age) },
    getId = { it.id }
)
```

- 用户只需 `@Entity` + data class
- KSP 生成 Statements、Store、RowMapper
- 业务层：`UserStore.get(1)` 或 `UserStore.where { }.list()`（主路径，AutoStore 已 deprecated）

---

## 7. 接口定型清单（v2 冻结）

| API | 说明 |
|-----|------|
| `Store.findById/findAll` | 保留 |
| `Store.insert/update/delete` | 保留，insert 返回 T（含生成 id） |
| `Store.save` | 保留，upsert 语义 |
| `Store.insertBatch/updateBatch/saveAll` | 新增 |
| `Store.query()` | 保留，后续演进为类型安全 DSL |
| `Store.withTransaction` | 新增 |
| `EntityStatements` | 新增，KSP 生成 `XxxStatements` object |
| `object UserStore : SqlxStore&lt;User&gt;` | 单例 Store |
| `interface UserRepository : Store&lt;User&gt;` | 可选，业务层类型语义 |
| `AutoStore.of&lt;T&gt;()` | legacy，不推荐 |
| `user.save(store)` | 新增，扩展函数 |
| `User.findById(id)` | 新增，伴生对象风格，可选 |

---

## 8. 实施优先级

1. **Statement 静态化**：KSP 生成 `XxxStatements` object
2. **Store 单例化**：`object UserStore : SqlxStore&lt;User&gt;`
3. **Batch API**：insertBatch、updateBatch、saveAll
4. **ActiveRecord 扩展**：`save(store)`、`delete(store)` 扩展函数
5. **withTransaction**：Store 级事务封装
6. **Typed Query DSL**：`where(User::email eq ...)`，KProperty → column，最高 DX 价值
7. **Stream/Flow 查询**：v3 可选，大表场景

**战略**：内核已定型，停止底层深挖 → 做上层能力（DSL、事务、生态）。

---

## 9. 冻结版接口文件（完整 Kotlin 草图）

可直接落地的接口层定义，供实现时对照。

```kotlin
// ========== Store 核心接口 ==========
interface Store<T : Any> {
    suspend fun findById(id: Any): T?
    suspend fun findAll(): List<T>
    suspend fun insert(entity: T): T
    suspend fun update(entity: T): Boolean
    suspend fun save(entity: T): T
    suspend fun delete(entity: T): Boolean
    suspend fun deleteById(id: Any): Boolean
    suspend fun count(): Long
    suspend fun exists(id: Any): Boolean
    suspend fun insertBatch(entities: List<T>): Int
    suspend fun updateBatch(entities: List<T>): Int
    suspend fun saveAll(entities: List<T>): List<T>
    fun query(): QueryBuilder<T>
    suspend fun <R> withTransaction(block: suspend Store<T>.() -> R): R
}

// ========== Statements 静态持有（KSP 生成） ==========
interface EntityStatements {
    val selectById: Statement
    val selectAll: Statement
    val countAll: Statement
    val insert: Statement
    val update: Statement
    val deleteById: Statement
}

// ========== SqlxStore 抽象（引用 Statements） ==========
abstract class SqlxStore<T : Any>(
    protected val db: Database,
    protected val statements: EntityStatements,
    protected val mapper: RowMapper<T>,
    protected val toParams: (T) -> Map<String, Any?>,
    protected val getId: (T) -> Any?
) : Store<T> {
    override suspend fun findById(id: Any): T? =
        db.fetchAll(statements.selectById.bind("id", id), mapper).getOrThrow().firstOrNull()
    override suspend fun findAll(): List<T> =
        db.fetchAll(statements.selectAll, mapper).getOrThrow()
    override suspend fun count(): Long =
        db.fetchOne(statements.countAll, RowMapper.long).getOrThrow() ?: 0L
    override suspend fun exists(id: Any): Boolean = findById(id) != null
    override suspend fun deleteById(id: Any): Boolean =
        db.execute(statements.deleteById.bind("id", id)).getOrThrow().rowsAffected > 0
    // insert/update/save/delete/insertBatch/updateBatch/saveAll/withTransaction 按前述章节实现
}

// ========== 示例：User（KSP 或手写） ==========
object UserStatements : EntityStatements {
    override val selectById = Statement.create("SELECT * FROM users WHERE id = :id")
    override val selectAll = Statement.create("SELECT * FROM users")
    override val countAll = Statement.create("SELECT COUNT(*) FROM users")
    override val insert = Statement.create("INSERT INTO users (id, name, age) VALUES (:id, :name, :age)")
    override val update = Statement.create("UPDATE users SET name = :name, age = :age WHERE id = :id")
    override val deleteById = Statement.create("DELETE FROM users WHERE id = :id")
}

interface UserRepository : Store<User>

object UserStore : Store<User> by SqlxStoreAdapter(  // 主路径：SqlxStoreAdapter
    meta = UserMeta, dbProvider = { SqlxDatabase.require() }, ...
), UserRepository

// ========== ActiveRecord 扩展 ==========
suspend fun <T : Any> T.save(store: Store<T>): T = store.save(this)
suspend fun <T : Any> T.delete(store: Store<T>): Boolean = store.delete(this)
```

- `EntityStatements` 接口约束 KSP 生成格式
- `SqlxStore` 只依赖 `EntityStatements`，不依赖具体实现
- 业务层：`UserStore.findById(1)` 或 `user.save(UserStore)`
